# Z-функция. Пусть у нас есть строка S, |S| = n. Тогда z[i] есть наибольшее число символов, которые совпадают у строк S и S[i:]. То есть это размер максимального общего префикса строки S и i-го суффикса строки S.

# Как вычислять Z-функцию? Наивный подход работает за время порядка O(n^2). От нас хотят более эффективной реализации. Существует алгоритм, вычисляющий Z-функцию за время O(n). 

# Своего рода ДП. Будем проходиться по строке и считать z[i] поочереди. Помимо уже подсчитанных z[i] нам понадобится хранить так называемые "отрезки совпадения". Отрезок совпадения есть строка, совпадающая с префиксом S. То есть z[i] есть длина наибольшего отрезка совпадения, начинающегося в точке i.
# Какой именно отрезок совпадения мы хотим хранить? На очередном шаге мы хотим, дабы у нас был самый правый отрезок совпадения (мы будем их задавать как [l, r], и мы хотим хранить отрезок, чья r максимальная.

# Давайте поймём, как вычислять z-функцию, зная этот самый отрезок совпадения. z[i]:
# 1) i > r. Тогда будем считать z[i] наивным агоритмом. Если оказалось, что z[i] = 0, то двигаемся дальше. Если нет, то новый отрезок совпадения будет иметь вид [i, i + z[i] - 1]
# 2) i <= r. В таком случае мы можем заранее проинициализировать значение z[i] некоторым числом. Каким? Почему?
# Заметим, что подстроки S[l, ..., r] и S[0, ..., r - l] совпадают. Тогда утверждается, что для приближения начального значения z[i] мы можем взять соответствующее значения из префикса длины r - l, а именно z[i - l].
#
# a_l....a_i.......a_r....
# a_0....a_{i-l}...a_{r-l}.....
# Однако, есть один нюанс. Если z[i - l] велико, то возникают проблемы. Что делать? Да просто установить z[i] = min(z[i - l], r - i + 1).
# И после такой инициализации мы догоняемся наивным алгоритмом. 

def z_foo(s):
    n = len(s)
    z = [0 for i in range(n)]
    l, r = 0, 0
    for i in range(1, n):
        if i > r:
            z[i] = 0
        if i <= r:
            z[i] = min(r - i, z[i - l])
        while i + z[i] < n and s[z[i]] == s[z[i] + i]:
            z[i] += 1
        if i + z[i] > r and z[i] != 0:
            l, r = i, i + z[i]
    return z


s = input()
z = z_foo(s)
for elem in z:
    print(elem, end=' ')
print()
